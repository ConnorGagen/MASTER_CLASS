---
title: "02_peaks_and_promoters"
author: "JR"
date: "2024-11-21"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# GOAL : #################

```{r setting up information to load peak files}

# sourcing import peaks function 
source("../../util/00_our_first_function_lesson.R")

# establishing peak path to the dir with MACS2 output peak files from NF_CORE ATACseq pipeline
peak_path <- "/scratch/Shares/rinnclass/MASTER_CLASS/lessons/08_ATACseq_pipeline/00_run_pipeline/00_pipeline_run/pipeline_run/bwa/merged_library/macs2/broad_peak"

# creating a file list also needed for import_peaks function
fl <- list.files(peak_path, full.names = TRUE, pattern = ".broadPeak")
```

# Run import_peaks function to get a list of ATAC peak files in GRanges format

```{r run import_peaks}

my_peaks <- import_peaks(consensus_file_path = peak_path)

# Nice so with a list of peak files and path to the folder we can load as many peak files as we need !
num_peaks <- sapply(my_peaks, length) %>% as.data.frame
view(num_peaks)

# printing to compare later to filtered to cannonical chromosomes  
print(num_peaks)

```

# Now let's find a set of peaks that are common to all the samples !
We previously looked at the overlap between WT_0 and KO_O now let's find the peaks that are in all files.
Let's go through each step and then 


# Step one Genomic ranges reduce function across the list of GRanges for each ATACseq peak file: 
The GenomicRanges::reduce function in the GenomicRanges package merges overlapping or adjacent genomic ranges into a single range, depending on a specified rule. 
# By default, it takes the outermost boundaries of all overlapping or adjacent ranges, creating the smallest set of non-overlapping ranges that span all the input ranges.

# Let's put it to use and find peaks in all time points !
```{r all time point consensus peaks}
# making a list of peak files 
fl <- list.files(peak_path, 
                 full.names=TRUE, pattern = ".broadPeak")

# Extracting sample name from file name
sample_name <- sapply(fl, function(y){
 y <-  str_extract(y, "(KO|WT)_control_\\d+")
  
})

# Now we have the needed inputs to make a function !
# Let's make a fucntion to create peaks in all input files.
# Also to count how many peaks are in each file (number of overlaps)
```


```{r}

# (1) input parameter "gr_list" or my_peaks currently.
  find_common_peaks <- function(gr_list) {

# (2) reduce any overlapping peaks in each file
  # lapply() will loop us through each entry in our gr_list
  # Reduce each GRanges so there are no overlapping intervals
  reduced_list <- lapply(gr_list, reduce)
  
# (3) now find overlaps across all samples
  common_peaks <- reduced_list[[1]]
 # Sequentially find overlaps with the next GRanges object
  # Sequentially find overlaps with the next GRanges object
  for (i in 2:length(gr_list)) {
    # Find overlaps between common_peaks and the current GRanges
    overlaps <- findOverlaps(common_peaks, gr_list[[i]])
    
    # Subset the overlapping ranges
    common_peaks <- common_peaks[queryHits(overlaps)]
  }
  
  # Reduce the resulting ranges to merge the overlapping regions
  common_peaks <- reduce(common_peaks)
  
  return(common_peaks)
}

# Find the peaks that overlap in all samples
common_peaks <- find_common_peaks(gr_list)

# Print the result
common_peaks
```









# Creating consensus peak and overlap counting function : create_consensus_reduced
First the parameters:
```{r}

#' CREATE CONSENSUS PEAKS
#' this function will take multiple replicate .broadPeak files (also narrow)
#' find peaks that overlap in all the replicates. 
#' @description 
#' input set of chipseq replicate peak files
#' this function then creates one merged file peaks in all samples
#' @param sample_name
#' This will be extracted with names(GR_list) in the lapply at end of fun
#' You will need a "dbps" or some object for the lapply that has the 
#' name of each dbp in the named GRanges list
#' 
#' @param my_peaks
#' Named list of GRanges for each ATACseq file
#' peak_list can be generated using "import_peaks" we created previously

consensus_from_reduced <- function(sample_name, my_peaks) {
  atac_peaks <- sample_name[grepl(as.character(sample_name), names(my_peaks))]
  suppressWarnings(all_peaks <- GenomicRanges::reduce(unlist(as(atac_peaks, my_peaks))))
  all_peaks <- all_peaks[grepl("chr", seqnames(all_peaks))]
  
  # peak_exists <- lapply(dbp_peaks, function(x) {
  #   as.numeric(countOverlaps(all_peaks, x) > 0))
  # }) %>%
  # bind_rows() OR bind_cols()
  peak_exists <- matrix(NA, nrow = length(all_peaks), ncol = length(my_peaks))
  for(i in 1:length(atac_peaks)) {
    suppressWarnings(peak_exists[,i] <- as.numeric(countOverlaps(my_peaks, atac_peaks[[i]]) > 0))
  }

# filter to consensus requiring peaks to be in all replicates
dbp_consensus <- all_peaks[rowSums(peak_exists) == ncol(peak_exists)]
# Required only two replicates == dbp_consensus <- all_peaks[rowSums(peak_exists) > 1]
return(dbp_consensus)
}

test <- consensus_from_reduced(sample_name, my_peaks)
```




```{r all time point consensus peaks}
all_peaks <- GenomicRanges::reduce(unlist(as(sample_name, my_peaks)))

suppressWarnings
test <- GenomicRanges::reduce(unlist(as(sample_name, "GRangesList"
                                        
                                        


```


```{r}





consensus_from_reduced <- function(dbp, peak_list) {
  dbp_peaks <- peak_list[grepl(as.character(dbp), names(peak_list))]
  suppressWarnings(all_peaks <- GenomicRanges::reduce(unlist(as(dbp_peaks, "GRangesList"))))
  all_peaks <- all_peaks[grepl("chr", seqnames(all_peaks))]
  
  # peak_exists <- lapply(dbp_peaks, function(x) {
  #   as.numeric(countOverlaps(all_peaks, x) > 0))
  # }) %>%
  # bind_rows() OR bind_cols()
  peak_exists <- matrix(NA, nrow = length(all_peaks), ncol = length(dbp_peaks))
  for(i in 1:length(dbp_peaks)) {
    suppressWarnings(peak_exists[,i] <- as.numeric(countOverlaps(all_peaks, dbp_peaks[[i]]) > 0))
  }

# filter to consensus requiring peaks to be in all replicates
dbp_consensus <- all_peaks[rowSums(peak_exists) == ncol(peak_exists)]
# Required only two replicates == dbp_consensus <- all_peaks[rowSums(peak_exists) > 1]
return(dbp_consensus)
}

```



First let's find the 
peaks that are common in the 0 time point and compare them to