---
title: "02_peaks_and_promoters"
author: "JR"
date: "2024-11-21"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# GOAL : #################

```{r setting up information to load peak files}

# sourcing import peaks function 
source("../../util/00_our_first_function_lesson.R")

# establishing peak path to the dir with MACS2 output peak files from NF_CORE ATACseq pipeline
peak_path <- "/scratch/Shares/rinnclass/MASTER_CLASS/lessons/08_ATACseq_pipeline/00_run_pipeline/00_pipeline_run/pipeline_run/bwa/merged_library/macs2/broad_peak"

# creating a file list also needed for import_peaks function
fl <- list.files(peak_path, full.names = TRUE, pattern = ".broadPeak")
```

# Run import_peaks function to get a list of ATAC peak files in GRanges format

```{r run import_peaks}

my_peaks <- import_peaks(consensus_file_path = peak_path)

# Nice so with a list of peak files and path to the folder we can load as many peak files as we need !
num_peaks <- sapply(my_peaks, length) %>% as.data.frame
view(num_peaks)

# printing to compare later to filtered to cannonical chromosomes  
print(num_peaks)

```

# Now let's find a set of peaks that are common to all the samples !
We previously looked at the overlap between WT_0 and KO_O now let's find the peaks that are in all files.
Let's go through each step and then 


# Step one Genomic ranges reduce function across the list of GRanges for each ATACseq peak file: 
The GenomicRanges::reduce function in the GenomicRanges package merges overlapping or adjacent genomic ranges into a single range, depending on a specified rule. 
# By default, it takes the outermost boundaries of all overlapping or adjacent ranges, creating the smallest set of non-overlapping ranges that span all the input ranges.

# Let's put it to use and find peaks in all time points !
```{r}




```


```{r}





consensus_from_reduced <- function(dbp, peak_list) {
  dbp_peaks <- peak_list[grepl(as.character(dbp), names(peak_list))]
  suppressWarnings(all_peaks <- GenomicRanges::reduce(unlist(as(dbp_peaks, "GRangesList"))))
  all_peaks <- all_peaks[grepl("chr", seqnames(all_peaks))]
  
  # peak_exists <- lapply(dbp_peaks, function(x) {
  #   as.numeric(countOverlaps(all_peaks, x) > 0))
  # }) %>%
  # bind_rows() OR bind_cols()
  peak_exists <- matrix(NA, nrow = length(all_peaks), ncol = length(dbp_peaks))
  for(i in 1:length(dbp_peaks)) {
    suppressWarnings(peak_exists[,i] <- as.numeric(countOverlaps(all_peaks, dbp_peaks[[i]]) > 0))
  }

# filter to consensus requiring peaks to be in all replicates
dbp_consensus <- all_peaks[rowSums(peak_exists) == ncol(peak_exists)]
# Required only two replicates == dbp_consensus <- all_peaks[rowSums(peak_exists) > 1]
return(dbp_consensus)
}

```



First let's find the 
peaks that are common in the 0 time point and compare them to