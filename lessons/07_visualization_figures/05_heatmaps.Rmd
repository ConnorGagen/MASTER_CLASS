---
title: "05_heatmaps"
author: "JR"
date: "2024-08-13"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reshape)
library(tidyr)
library(tibble)
library(ggplot2)
library(dplyr)
library(pheatmap)
source("../../util/plot_theme.R")

```

# Goal create "heatmaps"to represent gene abundance across time and replicates.
Heatmaps are a very common and powerful way to represent RNAseq data. It shows the 
abundance of each gene, across all samples and shades them in colore
for more or less abundant expression (e.g., red high, blue low). Moreover, a heatmap can
be combined with a "clustering" algorithm to organize the patterns in the data. Finally, 
this also tells you how related samples are. We can do this in two steps:

# (1) cluster our samples to find the relationship across samples
# (2) cluster and overlay heatmap of gene abundance across time of dox exposure

Let's get started with "clustering our samples"
First let's load the data

```{r Loading data}

# load TPM RESULTS: 
load("/scratch/Shares/rinnclass/MASTER_CLASS/lessons/06_Differential_expression_analyses/results/TPM_results/TPM_results.Rdata")

# laod DESEQ2 results
load("/scratch/Shares/rinnclass/MASTER_CLASS/lessons/06_Differential_expression_analyses/results/counts_results_DESEQ/DESEQ_results.rdata")

```

# (1) Cluster samples
First step is calculating distance between all samples. Let's start with our
TPM data as these are the values typically used for clustering and heatmaps. 

# Note use of transmute (t) 
# Note log TPM values being used
```{r distance calculation}

# Log-transform the TPM values. 
# This helps deflate spurious and low values - common practice for clustering/heatmaps
log_tpm_matrix <- log2(TPM_filtered + 1)

# Now let's calculate how closely related each sample (time point) is to each other using DIST function.
# We make a vector the length of genes in TPM_filtered. Then use correlation (DIST function) to find similarity.
# For other methods check out dist menu 
?dist

# Let's start with euclidean distance / similarity based on log2 TPM values of genes in TPM_filtered.
distance_matrix <- dist(t(log_tpm_matrix), method = "euclidean")

# Now we use the function : HCLUST ! 
# This performs the hierarchical clustering of each samples relationship
?hclust
# Other forms of clustering as well see menu above for now ward or complete
# Downside of ward is it assumes a circle relationship where as complete is linear - like we have with time.
hc_complete <- hclust(distance_matrix, method = "complete")

# Now we can use plot() to plot the distance calucalated in hclust!
plot(hc_complete, labels = colnames(log_tpm_matrix), main = "Global TPM Filtered Dendrogram ", sub = "sample relationship by time and replicate after dox treatment")

# Cool we see that samples see to return closer to 0 after 96 hours of dox treatment
# Also that the replicates are more similar than time points - a very good / expected thing 

# Cut tree to limit the clusters 
clusters <- cutree(hc_complete, k = 5)
# Print out which sample is in which cluster
print(clusters)
# Cool we can see each time point is represented in each cluster !

```

# Supervised ordering of dendogram
Above we let the distances set where the samples end up. 
However we can force it to order the samples the way we want
Strategy: make a dendrogram and then reorder it 

# Let's order the samples and see how things change
```{r ordered dendrogram}

# Making a dendrogram of hc_complete
dend_hc_complete <- as.dendrogram(hc_complete)
view(dend_hc_complete)

# Reorder the dendrogram based on the clusters created above
dend_hc_complete <- reorder(dend, clusters)

# Plot the reordered dendrogram
plot(dend_hc_complete, main = "Global TPM Filtered Dendrogram (Ordered by Cluster)", sub = "Sample relationship by time and replicate after dox treatment")

# Voila they are ordered now - not still takes into consideration similarity when ordering !

```
# RESULT: Time points 0,12,96 more similar than 24, 48
# Intrepretation: this could mean most changes occur at 24-48 hours.


# (2) Overlapy a heatmap to measure sample similarity and gene changes across time
# PHEATMAP is a great program for making heat maps it will do 
```{r Create Heat map of all filtered TPM genes across all time points and replicates}

# THIS TAKES 3 MIN - but worth it 
pheatmap(log_tpm_matrix, 
         cluster_rows = TRUE,  # Cluster genes (rows)
         cluster_cols = TRUE,  # Cluster samples (columns)
         scale = "row",        # Scale the data across rows (genes) for better visualization
         show_rownames = FALSE, # Hide gene names for clarity
         show_colnames = TRUE,  # Show sample names
         main = "Heatmap of Log2-Transformed TPM Values for Sig genes")

#TODO include as bonus? 

custom_dist <- function(x) dist(x, method = "manhattan") # Replace "manhattan" with your preferred method
custom_hclust <- function(x) hclust(x, method = "ward.D2") # Replace "ward.D2" with your preferred clustering method

# Create a heatmap with custom distance and clustering functions
pheatmap(log_tpm_matrix, 
         cluster_rows = TRUE,  # Cluster genes (rows)
         cluster_cols = TRUE,  # Cluster samples (columns)
         scale = "row",        # Scale the data across rows (genes) for better visualization
         show_rownames = FALSE, # Hide gene names for clarity
         show_colnames = TRUE,  # Show sample names
         main = "Heatmap of Log2-Transformed TPM Values",
         distfun = custom_dist,    # Apply custom distance function
         hclustfun = custom_hclust # Apply custom clustering function
)


```


# Let's filter to sig genes
```{r}

sig_log_tpm_matrix <- log_tpm_matrix[rownames(log_tpm_matrix) %in% unique_sig_genes, ]

sig_distance_matrix <- dist(t(sig_log_tpm_matrix), method = "euclidean")

hc_sig_distance_matrix <- hclust(sig_distance_matrix, method = "ward.D2")

plot(hc_sig_distance_matrix, labels = colnames(hc_sig_distance_matrix), main = "Global TPM Sig Genes Dendrogram ", sub = "sample relationship by time and replicate after dox treatment for sig genes")


```

# Counts / rlog counts







# EXTRA

```{r}

# Cool we see if we choose 5 bins each time point falls into a bin with replicates !

ordered_colnames <- sort(colnames(log_tpm_matrix))
ordered_log_tpm_matrix <- log_tpm_matrix[, ordered_colnames]
hc_ordered <- hclust(dist(t(ordered_log_tpm_matrix)), method = "ward.D2")

# Step 3: Plot the dendrogram
plot(hc_ordered, labels = ordered_colnames, main = "Global TPM Filtered Dendrogram", 
     sub = "Sample relationship by time and replicate after dox treatment")

ordered_hclust <- hc$labels[hc$order]


ordered_hclust <- hc$labels[hc$order]

plot(ordered_hclust, labels = colnames(log_tpm_matrix), main = "Global TPM Filtered Dendrogram ", sub = "sample relationship by time and replicate after dox treatment")


```






